# -*- coding: utf-8 -*-
"""AIAssignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/172N0BvK_1E6eZMqKEgP4GPwQFlA1n_RV
"""

#ALL IMPORTS
import numpy as np
import math 
from queue import PriorityQueue
from queue import Queue 
from queue import LifoQueue

"""**CHANGE THE HEURISTIC DISTANCE BY CALLING MANHATTAN OR EUCLIDEAN FUNCTIONS **"""

class Puzzle(object):# class representing the puzzle

  def __init__(self, array,parent):  # a puzzle has 2 attributes the array of values and a parent representing the previous state
    self.array = array
    self.parent = parent
    self.cost = 0.0

  def blankLocation(self):  # function to get the position of the empty location
    for i in range(self.array.shape[0]):
      for j in range(self.array.shape[1]):
        if self.array[i][j] == 0:
          return i, j

  def canMoveRight(self, index):  # function to check right move
    if index[1] == 2:
      return False
    return True

  def canMoveLeft(self, index):  # function to check left move
    if index[1] == 0:
      return False
    return True

  def canMoveUp(self, index):  # function to check up move
    if index[0] == 0:
      return False
    return True

  def canMoveDown(self, index):  # function to check down move
    if index[0] == 2:
      return False
    return True

  def moveUp(self, index):  # function that generates the puzzle that comes about moving up
    x = np.copy(self.array)
    i = index[0]
    j = index[1]
    x[i][j], x[i - 1][j] = x[i - 1][j], x[i][j]
    return x

  def moveDown(self, index):  # function that generates the puzzle that comes about moving down
    x = np.copy(self.array)
    i = index[0]
    j = index[1]
    x[i][j], x[i + 1][j] = x[i + 1][j], x[i][j]
    return x

  def moveLeft(self, index):  # function that generates the puzzle that comes about moving left
    x = np.copy(self.array)
    i = index[0]
    j = index[1]
    x[i][j], x[i][j - 1] = x[i][j - 1], x[i][j]
    return x

  def moveRight(self, index):  # function that generates the puzzle that comes about moving right
    x = np.copy(self.array)
    i = index[0]
    j = index[1]
    x[i][j], x[i][j + 1] = x[i][j + 1], x[i][j]
    return x

  def isGoal(self):  # function that checks wether the current puzzle has been solved or not
    goal = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
    if np.array_equal(goal, self.array):
      return True
    return False

  def array2string(self):  # function that converts the 2d array to string
    string = ""
    for i in range(0, self.array.shape[0]):
      for j in range(0, self.array.shape[1]):
        string += str(self.array[i][j])
    return string

  def manhattanDistance(self, array):
    goal = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
    sum = 0
    for i in range(0, array.shape[0]):
      for j in range(0, array.shape[1]):
        indeces = np.where(goal == array[i][j])
        row = indeces[0][0]
        col = indeces[1][0]
        sum += abs(i - row) + abs(j - col)
    return sum

  def euclideanDistance(self, array):
    goal = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
    sum = 0
    for i in range(0, self.array.shape[0]):
      for j in range(0, self.array.shape[1]):
        indeces = np.where(goal == self.array[i][j])
        row = indeces[0][0]
        col = indeces[1][0]
        sum += math.sqrt((i - row) ** 2) + math.sqrt( (j - col) ** 2)
    return sum

  def CalcHeuristic(self, array):
    return self.euclideanDistance(array) + self.cost
    #return self.manhattanDistance(array) + self.cost

  def __lt__(self, other):
    return self.CalcHeuristic(self.array) < self.CalcHeuristic(other.array)

  def __eq__(self, other):
    return self.CalcHeuristic(self.array) == self.CalcHeuristic(other.array)

class Queue(): #class that represents the queue to use,having an actual queue and a helping hashtable alongside it to speed up the search 
  
  def __init__(self): #a queue object consists of a queue and a set 
    from queue import Queue 
    self.queue = Queue()
    self.set = set()

  def array2string(self,array): #function that converts the 2d array to string 
    string = ""
    for i in range(0,array.shape[0]):
      for j in range(0,array.shape[1]):
        string += str(array[i][j]) 
    return string

  def enqueue(self,object): #function that inserts data into both the queue and the set
    self.queue.put(object)
    self.set.add(self.array2string(object.array))

  def dequeue(self): #function that gets data out of both the queue and the set
    temp = self.queue.get()
    self.set.remove(self.array2string(temp.array))
    return temp

  def size(self): #function that gets the size of the queue 
    return self.queue.qsize()

class Stack(): #class that represents the stack to use,having an actual stack and a helping hashtable alongside it to speed up the search 
  
  def __init__(self): #a queue object consists of a stack and a set 
    from queue import LifoQueue 
    self.stack = LifoQueue()
    self.set = set()

  def array2string(self,array): #function that converts the 2d array to string 
    string = ""
    for i in range(0,array.shape[0]):
      for j in range(0,array.shape[1]):
        string += str(array[i][j]) 
    return string

  def push(self,object): #function that inserts data into both the stack and the set
    self.stack.put(object)
    self.set.add(self.array2string(object.array))

  def pop(self): #function that gets data out of both the stack and the set
    temp = self.stack.get()
    self.set.remove(self.array2string(temp.array))
    return temp

  def size(self): #function that gets the size of the stack 
    return self.stack.qsize()

class priorityQueue():   #class that represents the heap to use,having an actual heap and a helping hashtable alongside it to speed up the search 
  
  def __init__(self): #a priority queue object consists of a stack and a set 
    from queue import PriorityQueue 
    self.pq = PriorityQueue()
    self.set = set()

  def array2string(self,array): #function that converts the 2d array to string 
    string = ""
    for i in range(0,array.shape[0]):
      for j in range(0,array.shape[1]):
        string += str(array[i][j]) 
    return string

  def put(self,object): #function that inserts data into both the heap and the set
    self.pq.put(object)
    self.set.add(self.array2string(object.array))

  def get(self): #function that gets data out of both the stack and the set
    temp = self.pq.get()
    self.set.remove(self.array2string(temp.array))
    return temp

  def remove(self,x):
    pqtemp = PriorityQueue()
    self.set.remove(self.array2string(x.array))
    while not self.pq.empty():
      temp = self.pq.get()
      if np.array_equal(temp.array, x.array):
        val = temp
      else:
        pqtemp.put(temp)
    self.pq = pqtemp
    return val

  def empty(self): #function that gets the size of the stack 
    return self.pq.empty()

def formNeighbors(puzzle): #function that forms the corrosponding puzzles to every legal possible move
  neighbors = []
  index = puzzle.blankLocation()
  if puzzle.canMoveUp(index):
    x = puzzle.moveUp(index)
    neighbors.append(x)

  if puzzle.canMoveDown(index):
    x = puzzle.moveDown(index)
    neighbors.append(x)

  if puzzle.canMoveLeft(index):
    x = puzzle.moveLeft(index)
    neighbors.append(x)

  if puzzle.canMoveRight(index):
    x = puzzle.moveRight(index)
    neighbors.append(x)

  neighbors = np.array(neighbors)
  return neighbors

def BFS(initial):
  fronteir = Queue()
  visited = set()
  fronteir.enqueue(initial)
  while not fronteir.size() == 0:
    state = fronteir.dequeue()
    visited.add(state.array2string())
    if state.isGoal():
      return state, visited
    neighbors = formNeighbors(state)
    for neighbor in neighbors:
      n = Puzzle(neighbor, state)
      n.cost = 1 + n.parent.cost
      if not n.array2string() in visited:
        if not n.array2string() in fronteir.set:
          fronteir.enqueue(n)

def DFS(initial): 
  fronteir = Stack()
  visited = set()
  fronteir.push(initial)
  while not fronteir.size() == 0:
    state = fronteir.pop()
    visited.add(state.array2string())
    if state.isGoal():
      return state,visited
    neighbors = formNeighbors(state)
    for neighbor in neighbors:
      n = Puzzle(neighbor,state)
      n.cost = 1 + n.parent.cost
      if not n.array2string() in visited:
        if not n.array2string() in fronteir.set:
          fronteir.push(n)

def A_star(initial): 
  fronteir = priorityQueue()
  visited = set()
  fronteir.put(initial)
  while not fronteir.empty():
    state = fronteir.get()
    visited.add(state.array2string())
    if state.isGoal():
      return state,visited
    neighbors = formNeighbors(state)
    for neighbor in neighbors:
      n = Puzzle(neighbor,state)
      n.cost = 1 + n.parent.cost
      if not n.array2string() in visited:
        if not n.array2string() in fronteir.set:
          fronteir.put(n)
        else:
          temp = fronteir.remove(n)
          if temp.cost > n.cost:
            fronteir.put(n)
          else:
            fronteir.put(temp)

def path(result): #function that forms the path to win 
  if not result.parent:
    print(result.array)
    depth = 0
    return depth
  from queue import LifoQueue
  s = LifoQueue() 
  while result.parent:
    s.put(result)
    result = result.parent
  depth = s.qsize()
  s.put(result)
  #while not s.qsize() == 0:
    #print(s.get().array)
  return depth

"""# **START OF CODE**"""

x = np.array([[1,2,0],[4,5,3],[7,8,6]])
y = np.array([[1,2,0],[3,4,5],[6,7,8]])
pdf_initial = Puzzle(x,None)
#start = Puzzle(rand_array,None)
print(x)

rand = np.zeros((3,3))
for i in range(0,3):
  for j in range(0,3):
    val = int(input("Enter your value: ") )
    rand[i][j]= int(val)
print(rand) 
start = Puzzle(rand,None)

"""# **BFS**"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# resBFS,visBFS = BFS(pdf_initial)
# dBFS = path(resBFS)
# print(dBFS)
# print(resBFS.cost)

"""# **DFS**"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# resDFS,visDFS = DFS(pdf_initial)
# #dDFS = path(resDFS)
# #print(dDFS)
# print(resDFS.cost)

"""# **A***"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# resA,visA = A_star(pdf_initial)
# print(resA.parent.array)
# dA = path(resA)
# print(dA)
# print(resA.cost)